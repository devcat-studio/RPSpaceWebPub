<!DOCTYPE html>
<html>

<body style="margin: 0px; overflow: hidden;">
    <div id="player"></div>

    <script>
        // PlayerWrapper 클래스 선언 - 프록시 패턴으로 YouTube Player API 연결
        class PlayerWrapper {
            constructor(elementId, options = {}) {
                this._player = null;
                this._ready = false;
                this._elementId = elementId;
                this._options = options;
                this._onReadyCallbacks = [];
                this._onStateChangeCallbacks = [];
                this._pendingLoadVideo = null; // 플레이어 준비 전 loadVideoById 호출 저장
                this._pendingPlay = false; // 플레이어 준비 전 playVideo 호출 저장
                this._playRequestId = 0; // play 요청 추적 (타이머 stale 방지)
            }

            // 내부 플레이어 초기화
            initPlayer() {
                console.log("Initializing YouTube Player");
                this._player = new YT.Player(this._elementId, {
                    height: this._options.height || '480',
                    width: this._options.width || '640',
                    videoId: this._options.videoId || '',
                    playerVars: {
                        'playsinline': 1,
                        'autoplay': 0,
                        ...this._options.playerVars
                    },
                    events: {
                        'onReady': (event) => this._handleReady(event),
                        'onStateChange': (event) => this._handleStateChange(event),
                        'onError': (event) => this._handleError(event),
                        'onAutoplayBlocked': (event) => this._handleAutoplayBlocked(event)
                    }
                });
            }

            // 내부 이벤트 핸들러
            _handleReady(event) {
                console.log("Player is ready");
                this._ready = true;

                // 펜딩된 loadVideoById 호출 실행
                if (this._pendingLoadVideo) {
                    const { videoId, startSeconds } = this._pendingLoadVideo;
                    this._pendingLoadVideo = null;
                    this._player.loadVideoById(videoId, startSeconds);
                }

                // 펜딩된 playVideo 호출 실행
                if (this._pendingPlay) {
                    this._pendingPlay = false;
                    this.playVideo();
                }

                this._onReadyCallbacks.forEach(cb => cb(event));
            }

            _handleStateChange(event) {
                console.log("Player state changed to: " + event.data);
                this._onStateChangeCallbacks.forEach(cb => cb(event));
            }

            _handleError(event) {
                // 모바일/웹뷰 환경에서 사용자 제스처 없이 재생 시도가 막힐 때 error 콜백이 오거나,
                // state가 PLAYING으로 전환되지 않는 경우가 있어, 네이티브에 안내할 수 있게 한다.
                console.log("Player error:", event && event.data);
            }

            _handleAutoplayBlocked(event) {
                console.log("Autoplay blocked event:", event);

                // 반응 테스트용 주석 처리
                // this._notifyUserGestureRequired('autoplayBlocked', {
                //     source: 'onAutoplayBlocked',
                //     data: event && event.data
                // });
            }


            _notifyUserGestureRequired(reason, extra = {}, x = 0.5, y = 0.5) {
                console.log("Notifying native of user gesture requirement:", reason, extra);
                this.postJsonToNative({
                    Type: 'userGestureRequired',
                    Action: 'clickToPlay',
                    X: x,
                    Y: y,
                    Reason: reason,
                    ...extra
                });
            }

            // 이벤트 콜백 등록
            onReady(callback) {
                this._onReadyCallbacks.push(callback);
                if (this._ready) callback({ target: this._player });
            }

            onStateChange(callback) {
                this._onStateChangeCallbacks.push(callback);
            }

            // 프록시 메서드들 - 재생 제어
            playVideo() {
                if (!(this._player && this._ready)) {
                    console.log("Player not ready, deferring playVideo");
                    this._pendingPlay = true;
                    return;
                }

                // play 지시 후 실제로 재생이 시작되지 않으면(모바일 자동재생 제한 등)
                // 네이티브에 사용자 클릭 유도를 요청한다.
                const requestId = ++this._playRequestId;
                this._player.playVideo();

                // const checkPlayback = (delayMs) => {
                //     window.setTimeout(() => {
                //         if (requestId !== this._playRequestId) return; // 최신 요청만 처리
                //         const state = this.getPlayerState();
                //         const isPlaying = state === YT.PlayerState.PLAYING;
                //         const isBuffering = state === YT.PlayerState.BUFFERING;
                //         if (isPlaying) return;

                //         // BUFFERING이면 조금 더 기다렸다가 최종 확인
                //         if (isBuffering && delayMs < 2000) {
                //             checkPlayback(2500);
                //             return;
                //         }

                //         // print state for debugging
                //         console.log("Playback check: state =", state);

                //         this._notifyUserGestureRequired('autoplayBlocked', {
                //             state
                //         });
                //     }, delayMs);
                // };

                // checkPlayback(1500);
            }

            pauseVideo() {
                console.log("Pausing video");
                if (this._player && this._ready) this._player.pauseVideo();
            }

            stopVideo() {
                console.log("Stopping video");
                if (this._player && this._ready) this._player.stopVideo();
            }

            seekTo(seconds, allowSeekAhead = true) {
                console.log("Seeking to:", seconds, "Allow seek ahead:", allowSeekAhead);
                if (this._player && this._ready) this._player.seekTo(seconds, allowSeekAhead);
            }

            // 프록시 메서드들 - 볼륨 제어
            mute() {
                console.log("Muting video");
                if (this._player && this._ready) this._player.mute();
            }

            unMute() {
                console.log("Unmuting video");
                if (this._player && this._ready) this._player.unMute();
            }

            isMuted() {
                console.log("Checking if video is muted");
                return this._player && this._ready ? this._player.isMuted() : false;
            }

            setVolume(volume) {
                console.log("Setting volume to:", volume);
                if (this._player && this._ready) this._player.setVolume(volume);
            }

            getVolume() {
                console.log("Getting current volume");
                return this._player && this._ready ? this._player.getVolume() : 0;
            }

            // 프록시 메서드들 - 영상 정보
            getDuration() {
                return this._player && this._ready ? this._player.getDuration() : 0;
            }

            getCurrentTime() {
                return this._player && this._ready ? this._player.getCurrentTime() : 0;
            }

            getPlayerState() {
                return this._player && this._ready ? this._player.getPlayerState() : -1;
            }

            getVideoUrl() {
                return this._player && this._ready ? this._player.getVideoUrl() : '';
            }

            getVideoEmbedCode() {
                return this._player && this._ready ? this._player.getVideoEmbedCode() : '';
            }

            // 프록시 메서드들 - 영상 로드
            loadVideoById(videoId, startSeconds = 0) {
                if (this._player && this._ready) {
                    console.log("Loading video by ID:", videoId, "at", startSeconds);
                    this._player.loadVideoById(videoId, startSeconds);
                } else {
                    // 플레이어가 준비되지 않았으면 나중에 실행하도록 저장
                    console.log("Player not ready, deferring loadVideoById:", videoId, "at", startSeconds);
                    this._pendingLoadVideo = { videoId, startSeconds };
                }
            }

            cueVideoById(videoId, startSeconds = 0) {
                console.log("Cueing video by ID:", videoId, "at", startSeconds);
                if (this._player && this._ready) this._player.cueVideoById(videoId, startSeconds);
            }

            // 프록시 메서드들 - 플레이어 크기
            setSize(width, height) {
                console.log("Setting player size to:", width, height);
                if (this._player && this._ready) this._player.setSize(width, height);
            }

            // 상태 확인
            isReady() {
                return this._ready;
            }

            // 내부 플레이어 직접 접근 (필요시)
            getInternalPlayer() {
                return this._player;
            }

            // Vuplex WebView 네이티브 메시지 전송
            postMessageToNative(message) {
                if (window.vuplex) {
                    window.vuplex.postMessage(message);
                } else {
                    console.warn("Vuplex WebView not available");
                }
            }

            // JSON 객체를 네이티브로 전송
            postJsonToNative(obj) {
                this.postMessageToNative(JSON.stringify(obj));
            }

        }

        // YouTube IFrame API 로드
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        // URL에서 파라미터 가져오기 (기본값 설정)
        var urlParams = new URLSearchParams(window.location.search);
        var videoId = urlParams.get('videoId') || '';
        var width = urlParams.get('width') || '640';
        var height = urlParams.get('height') || '480';

        // HTML 로드하자마자 PlayerWrapper 인스턴스 생성
        var player = new PlayerWrapper('player', {
            videoId: videoId,
            width: width,
            height: height
        });

        // YouTube API 준비 완료 시 플레이어 초기화
        function onYouTubeIframeAPIReady() {
            player.initPlayer();
        }

    </script>
</body>

</html>