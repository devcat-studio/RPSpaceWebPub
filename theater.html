<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Theater Debug</title>
    <style>
        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
        }

        #layout {
            display: grid;
            grid-template-rows: auto 1fr;
            height: 100%;
        }

        #header {
            padding: 10px 12px;
            background: #111;
            color: #fff;
            font-size: 13px;
            line-height: 1.4;
        }

        #content {
            display: grid;
            grid-template-columns: 1fr 420px;
            height: 100%;
            min-height: 0;
        }

        #player {
            display: grid;
            place-items: center;
            background: #000;
            color: rgba(255, 255, 255, 0.75);
            font-size: 14px;
        }

        #debugPanel {
            border-left: 1px solid #ddd;
            background: #fafafa;
            min-width: 280px;
            min-height: 0;
            display: grid;
            grid-template-rows: auto 1fr;
        }

        #debugTitle {
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
            font-weight: 600;
            font-size: 13px;
        }

        #callLog {
            margin: 0;
            padding: 10px 12px;
            overflow: auto;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .muted {
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <div id="layout">
        <div id="header">
            <div><b>Theater Debug</b> — 실제 YouTube는 로드/재생하지 않습니다.</div>
            <div class="muted">외부에서 기존과 동일하게 <code>player.*</code> API를 호출하면, 호출된 함수명/인자를 오른쪽 패널에 표시합니다.</div>
        </div>

        <div id="content">
            <div id="player">(YouTube disabled in debug)</div>

            <div id="debugPanel">
                <div id="debugTitle">API Call Log</div>
                <pre id="callLog"></pre>
            </div>
        </div>
    </div>

    <script>
        function _safeJson(value) {
            try {
                return JSON.stringify(value);
            } catch {
                return '"[unserializable]"';
            }
        }

        function _renderArg(value) {
            if (value instanceof Error) {
                return _safeJson({ name: value.name, message: value.message, stack: value.stack });
            }

            // Promise rejection reason 등이 문자열/객체/기타일 수 있어 방어적으로 처리
            const t = typeof value;
            if (value == null || t === 'number' || t === 'boolean') return String(value);
            if (t === 'string') return value;

            return _safeJson(value);
        }

        function _nowTime() {
            const d = new Date();
            return d.toISOString().slice(11, 23);
        }

        function logCall(name, args) {
            const el = document.getElementById('callLog');
            if (!el) return;

            const renderedArgs = args && args.length
                ? args.map(a => _renderArg(a)).join(', ')
                : '';

            el.textContent += `[${_nowTime()}] ${name}(${renderedArgs})\n`;
            el.scrollTop = el.scrollHeight;
        }

        // console.* 로 찍히는 로그/에러를 가로채서 패널에 표시 (원래 콘솔 출력은 유지)
        (function interceptConsole() {
            const methods = ['log', 'info', 'warn', 'error', 'debug'];
            const original = {};

            for (const m of methods) {
                if (typeof console[m] !== 'function') continue;
                original[m] = console[m].bind(console);
                console[m] = (...args) => {
                    try {
                        logCall(`console.${m}`, args);
                    } catch {
                        // 로깅 자체 실패 시 콘솔 기능을 깨지 않음
                    }
                    return original[m](...args);
                };
            }
        })();

        // 콘솔에 찍히지 않을 수도 있는 런타임 에러/리젝션도 패널에 남김
        window.addEventListener('error', (event) => {
            // event.error 가 Error 인스턴스일 수 있음
            logCall('window.error', [event && event.message, (event && event.error) || null, event && event.filename, event && event.lineno, event && event.colno]);
        });

        window.addEventListener('unhandledrejection', (event) => {
            logCall('window.unhandledrejection', [event && event.reason]);
        });

        // Debug 환경에서 vuplex가 없더라도 postMessage 호출을 확인할 수 있게 스텁 제공
        if (!window.vuplex) {
            window.vuplex = {
                postMessage: (message) => {
                    logCall('vuplex.postMessage', [message]);
                }
            };
        }

        // 실제 YouTube IFrame API 대신, 최소 동작만 하는 YT 스텁 제공
        (function installYTStub() {
            const PlayerState = {
                UNSTARTED: -1,
                ENDED: 0,
                PLAYING: 1,
                PAUSED: 2,
                BUFFERING: 3,
                CUED: 5
            };

            class StubPlayer {
                constructor(elementId, config) {
                    this._elementId = elementId;
                    this._config = config || {};
                    this._videoId = (config && config.videoId) || '';
                    this._width = (config && config.width) || '640';
                    this._height = (config && config.height) || '480';
                    this._muted = false;
                    this._volume = 100;
                    this._state = PlayerState.UNSTARTED;
                    this._currentTime = 0;
                    this._duration = 0;

                    window.setTimeout(() => {
                        const onReady = this._config && this._config.events && this._config.events.onReady;
                        if (typeof onReady === 'function') onReady({ target: this });
                    }, 0);
                }

                _emitStateChange(state) {
                    this._state = state;
                    const onStateChange = this._config && this._config.events && this._config.events.onStateChange;
                    if (typeof onStateChange === 'function') onStateChange({ data: state, target: this });
                }

                playVideo() {
                    this._emitStateChange(PlayerState.PLAYING);
                }

                pauseVideo() {
                    this._emitStateChange(PlayerState.PAUSED);
                }

                stopVideo() {
                    this._currentTime = 0;
                    this._emitStateChange(PlayerState.UNSTARTED);
                }

                seekTo(seconds, allowSeekAhead) {
                    this._currentTime = Number(seconds) || 0;
                }

                mute() {
                    this._muted = true;
                }

                unMute() {
                    this._muted = false;
                }

                isMuted() {
                    return this._muted;
                }

                setVolume(volume) {
                    const v = Number(volume);
                    this._volume = Number.isFinite(v) ? Math.max(0, Math.min(100, v)) : this._volume;
                }

                getVolume() {
                    return this._volume;
                }

                getDuration() {
                    return this._duration;
                }

                getCurrentTime() {
                    return this._currentTime;
                }

                getPlayerState() {
                    return this._state;
                }

                getVideoUrl() {
                    return this._videoId ? `https://www.youtube.com/watch?v=${this._videoId}` : '';
                }

                getVideoEmbedCode() {
                    return '';
                }

                loadVideoById(videoId, startSeconds) {
                    this._videoId = videoId || '';
                    this._currentTime = Number(startSeconds) || 0;
                    this._emitStateChange(PlayerState.CUED);
                }

                cueVideoById(videoId, startSeconds) {
                    this._videoId = videoId || '';
                    this._currentTime = Number(startSeconds) || 0;
                    this._emitStateChange(PlayerState.CUED);
                }

                setSize(width, height) {
                    this._width = width;
                    this._height = height;
                }
            }

            window.YT = {
                PlayerState,
                Player: StubPlayer
            };
        })();

        // PlayerWrapper 클래스 선언 - (디버그) YouTube 대신 YT 스텁으로 연결
        class PlayerWrapper {
            constructor(elementId, options = {}) {
                this._player = null;
                this._ready = false;
                this._elementId = elementId;
                this._options = options;
                this._onReadyCallbacks = [];
                this._onStateChangeCallbacks = [];
                this._pendingLoadVideo = null;
                this._pendingPlay = false;
                this._playRequestId = 0;

                this._installDebugMethodWrappers();
            }

            _installDebugMethodWrappers() {
                const methodsToLog = [
                    'initPlayer',
                    'onReady',
                    'onStateChange',
                    'playVideo',
                    'pauseVideo',
                    'stopVideo',
                    'seekTo',
                    'mute',
                    'unMute',
                    'isMuted',
                    'setVolume',
                    'getVolume',
                    'getDuration',
                    'getCurrentTime',
                    'getPlayerState',
                    'getVideoUrl',
                    'getVideoEmbedCode',
                    'loadVideoById',
                    'cueVideoById',
                    'setSize',
                    'isReady',
                    'getInternalPlayer',
                    'postMessageToNative',
                    'postJsonToNative'
                ];

                for (const name of methodsToLog) {
                    const original = this[name];
                    if (typeof original !== 'function') continue;
                    this[name] = (...args) => {
                        logCall(`player.${name}`, args);
                        return original.apply(this, args);
                    };
                }
            }

            // 내부 플레이어 초기화 (실제 YouTube 아님)
            initPlayer() {
                this._player = new YT.Player(this._elementId, {
                    height: this._options.height || '480',
                    width: this._options.width || '640',
                    videoId: this._options.videoId || '',
                    playerVars: {
                        'playsinline': 1,
                        'autoplay': 0,
                        ...this._options.playerVars
                    },
                    events: {
                        'onReady': (event) => this._handleReady(event),
                        'onStateChange': (event) => this._handleStateChange(event),
                        'onError': (event) => this._handleError(event),
                        'onAutoplayBlocked': (event) => this._handleAutoplayBlocked(event)
                    }
                });
            }

            // 내부 이벤트 핸들러
            _handleReady(event) {
                this._ready = true;

                // 펜딩된 loadVideoById 호출 실행
                if (this._pendingLoadVideo) {
                    const { videoId, startSeconds } = this._pendingLoadVideo;
                    this._pendingLoadVideo = null;
                    this._player.loadVideoById(videoId, startSeconds);
                }

                // 펜딩된 playVideo 호출 실행
                if (this._pendingPlay) {
                    this._pendingPlay = false;
                    this.playVideo();
                }

                this._onReadyCallbacks.forEach(cb => cb(event));
            }

            _handleStateChange(event) {
                this._onStateChangeCallbacks.forEach(cb => cb(event));
            }

            _handleError(event) {
                // 모바일/웹뷰 환경에서 사용자 제스처 없이 재생 시도가 막힐 때 error 콜백이 오거나,
                // state가 PLAYING으로 전환되지 않는 경우가 있어, 네이티브에 안내할 수 있게 한다.
                logCall('player._handleError', [event && event.data]);
            }

            _handleAutoplayBlocked(event) {
                logCall('player._handleAutoplayBlocked', [event && event.data]);

                this._notifyUserGestureRequired('autoplayBlocked', {
                    source: 'onAutoplayBlocked',
                    data: event && event.data
                });
            }


            _notifyUserGestureRequired(reason, extra = {}, x = 0.5, y = 0.5) {
                this.postJsonToNative({
                    Type: 'userGestureRequired',
                    Action: 'clickToPlay',
                    X: x,
                    Y: y,
                    Reason: reason,
                    ...extra
                });
            }

            // 이벤트 콜백 등록
            onReady(callback) {
                this._onReadyCallbacks.push(callback);
                if (this._ready) callback({ target: this._player });
            }

            onStateChange(callback) {
                this._onStateChangeCallbacks.push(callback);
            }

            // 프록시 메서드들 - 재생 제어
            playVideo() {
                if (!(this._player && this._ready)) {
                    this._pendingPlay = true;
                    return;
                }

                // play 지시 후 실제로 재생이 시작되지 않으면(모바일 자동재생 제한 등)
                // 네이티브에 사용자 클릭 유도를 요청한다.
                const requestId = ++this._playRequestId;
                this._player.playVideo();

                // const checkPlayback = (delayMs) => {
                //     window.setTimeout(() => {
                //         if (requestId !== this._playRequestId) return; // 최신 요청만 처리
                //         const state = this.getPlayerState();
                //         const isPlaying = state === YT.PlayerState.PLAYING;
                //         const isBuffering = state === YT.PlayerState.BUFFERING;
                //         if (isPlaying) return;

                //         // BUFFERING이면 조금 더 기다렸다가 최종 확인
                //         if (isBuffering && delayMs < 2000) {
                //             checkPlayback(2500);
                //             return;
                //         }

                //         // print state for debugging
                //         console.log("Playback check: state =", state);

                //         this._notifyUserGestureRequired('autoplayBlocked', {
                //             state
                //         });
                //     }, delayMs);
                // };

                // checkPlayback(1500);
            }

            pauseVideo() {
                if (this._player && this._ready) this._player.pauseVideo();
            }

            stopVideo() {
                if (this._player && this._ready) this._player.stopVideo();
            }

            seekTo(seconds, allowSeekAhead = true) {
                if (this._player && this._ready) this._player.seekTo(seconds, allowSeekAhead);
            }

            // 프록시 메서드들 - 볼륨 제어
            mute() {
                if (this._player && this._ready) this._player.mute();
            }

            unMute() {
                if (this._player && this._ready) this._player.unMute();
            }

            isMuted() {
                return this._player && this._ready ? this._player.isMuted() : false;
            }

            setVolume(volume) {
                if (this._player && this._ready) this._player.setVolume(volume);
            }

            getVolume() {
                return this._player && this._ready ? this._player.getVolume() : 0;
            }

            // 프록시 메서드들 - 영상 정보
            getDuration() {
                return this._player && this._ready ? this._player.getDuration() : 0;
            }

            getCurrentTime() {
                return this._player && this._ready ? this._player.getCurrentTime() : 0;
            }

            getPlayerState() {
                return this._player && this._ready ? this._player.getPlayerState() : -1;
            }

            getVideoUrl() {
                return this._player && this._ready ? this._player.getVideoUrl() : '';
            }

            getVideoEmbedCode() {
                return this._player && this._ready ? this._player.getVideoEmbedCode() : '';
            }

            // 프록시 메서드들 - 영상 로드
            loadVideoById(videoId, startSeconds = 0) {
                if (this._player && this._ready) {
                    this._player.loadVideoById(videoId, startSeconds);
                } else {
                    // 플레이어가 준비되지 않았으면 나중에 실행하도록 저장
                    this._pendingLoadVideo = { videoId, startSeconds };
                }
            }

            cueVideoById(videoId, startSeconds = 0) {
                if (this._player && this._ready) this._player.cueVideoById(videoId, startSeconds);
            }

            // 프록시 메서드들 - 플레이어 크기
            setSize(width, height) {
                if (this._player && this._ready) this._player.setSize(width, height);
            }

            // 상태 확인
            isReady() {
                return this._ready;
            }

            // 내부 플레이어 직접 접근 (필요시)
            getInternalPlayer() {
                return this._player;
            }

            // Vuplex WebView 네이티브 메시지 전송
            postMessageToNative(message) {
                window.vuplex.postMessage(message);
            }

            // JSON 객체를 네이티브로 전송
            postJsonToNative(obj) {
                this.postMessageToNative(JSON.stringify(obj));
            }

        }

        // URL에서 파라미터 가져오기 (기본값 설정)
        var urlParams = new URLSearchParams(window.location.search);
        var videoId = urlParams.get('videoId') || '';
        var width = urlParams.get('width') || '640';
        var height = urlParams.get('height') || '480';

        // HTML 로드하자마자 PlayerWrapper 인스턴스 생성
        var player = new PlayerWrapper('player', {
            videoId: videoId,
            width: width,
            height: height
        });

        // 디버그 페이지에서는 즉시 초기화한다 (실제 YouTube 로딩 없음)
        player.initPlayer();

        // 외부가 기존처럼 이 함수를 기대할 수 있어 유지
        function onYouTubeIframeAPIReady() {
            player.initPlayer();
        }

        var playerObjectIsValid = true;

    </script>
</body>

</html>